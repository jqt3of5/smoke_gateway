# Smoke Gateway
I recently saw an advertisement for a Thermoworks Smoke Gateway. A device that allows you to connect the Smoke to your WiFi network. Since the Smoke transmits wirelessly, 
the gateway is just a bridging device between that signal, and the wifi connection. At $100, I was inspiried to create my own open source version. 

Thanks to the helpful tips from skytoastar on this [project post](https://hackaday.io/project/160386-blanket-the-smoke-signal-gateway). Sleuthing around the FCC website they were able to determine the wireless chip used was an nrf24l01+. As well as some other important parameters required to receive data from the Smoke. After reading this I realized I had a handful of nrf24s, and an ESP32 just waiting to turn into a gateway. The one thing I did not have was the address the smoke was transmitting with. This is a necessary parameter in order to communicate with nrf24s. skytoastar used an expensive SDR to sniff the address. I didn't have one of those, but the project post suggested that an nrf24 could be configured to sniff out the address of transmitting devices. 

I found this [blog post](https://travisgoodspeed.blogspot.com/2011/02/promiscuity-is-nrf24l01s-duty.html) describing how to setup an nrf24 into promiscuous mode. Basically, the nrf24 will normally attempt to match messages that start with a preamble (alternating 1/0 at least one byte long. ex. 0x55/0xaa), then a 3-5 byte address, a payload of some known size, and end with a 2 byte CRC. The preamble, address, and CRC all have to checkout, otherwise the nrf24 will reject the packet and you wont recieve any data. According to the documentation, the only valid address widths are 3, 4, and 5 (Configured using the SETUP_AW register). However, it mentions writing a value of '0' to this register is illegal - but the researcher discovered that this actually enables a special mode that can be used as a semi-promiscuous mode. When SETUP_AW is "0", it won't match a preamble/address, but instead perform a two byte match against the LSBs of the address. A good place to start then is to write 0x00AA to the address register, and attempt to match on the preamble of the transmitting device. This will put the address in the payload which can be read out. 

Note: It's important to disable the CRC check in promiscuous mode, because it's very unlikely that the CRC will actually ever checkout when you're doing this. AutoAck must also be disabled, and you must disable it before you disable the CRC check per the datasheet

In semi-promiscuous mode, you're going to get a lot of noise. 0x00AA is a pretty common sequence, even in noisy environments, or environments where multiple nrf24 devices might be transmitting. This project doesn't include a utility to sort through the noise - but the process is simple. Find the most common 3 byte sequences in the recieved payloads. These are likely to be the fist three bytes of an address. Investigate the time between each transmission (Are they regular, every 10/20/30 seconds?). 

Note: The preamble might be longer than 8 bits. It can be multiple bytes, or even an odd number (Like 11). This means that there is a chance some of the preamble spills into the payload (Since we're only matching on the first 8 bits of preamble). It can get a little bit tricky then to determine which bit in the payload is actually the start of the address. It's a safe bet to assume it's one of the bits immediately after the alternating 1/0. In my case, I found the first byte in the payload that I could modify by interacting with the transmitting device, and counting back 40 bits. 

